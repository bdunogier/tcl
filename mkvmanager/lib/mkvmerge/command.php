<?php
/**
 * File containing the MKVMergeCommand class
 *
 * @version $Id$
 * @copyright 2010
 */

/**
 * This class allows manipulation of a mkvmerge command generated by the GUI
 */
class MKVMergeCommand
{
	/**
	 * Constructor
	 *
	 * @param string $command A mkvmerge command generated from the GUI
	 * @param string $targetDisk A mkvmerge command generated from the GUI
	 */
	function __construct( $command, $time = null )
	{
		if ( $time !== null )
			$this->time = $time;
		$this->command = $command;
		$this->_extractType();
		$this->_extractFiles();

	}

	protected function _extractFiles()
	{
		// Movie
		if ( $this->conversionType == 'movie' )
		{
			// parse the command to get the target / sources
			if ( preg_match( '#/media/storage/[^/]+/Movies/([^/]+)(/\1)?\.(avi|mkv)#', $this->command, $matches ) )
			{
				$this->title = $matches[1];
				$this->target = dirname( $matches[0] );

				// Replace the output conversion so that there is a subfolder for the movie
				if ( $matches[2] == '' )
				{
					$this->target .= DIRECTORY_SEPARATOR . $this->title;
					$fileTarget = $this->target . DIRECTORY_SEPARATOR . $this->title . '.' . $matches[3];
					$this->command = str_replace( $matches[0], $fileTarget, $this->command );
				}
			}
			else
			{
				throw new Exception( "Error extracting files from the command: {$this->command}" );
			}
			$this->linkTarget = "/media/aggregateshares/Movies/";
		}

		// TV Show
		elseif ( $this->conversionType == 'tvshow' )
		{
			// TV Show subfolder
			if ( preg_match( '#/media/storage/[^/]+/TV Shows/([^/]+)/([^/]+)\.(avi|mkv)#', $this->command, $matches ) )
			{
				$this->target = $matches[0];

				$this->showName = $matches[1];
				$this->episodeName = $matches[2];
			}
			// no subfolder
			elseif ( preg_match( '#/media/storage/[^/]+/TV Shows/(([^/]+) \- [0-9]+x[0-9]+ \- .*?)\.(avi|mkv)#', $this->command, $matches ) )
			{
				$this->target = $matches[0];

				$this->showName = $matches[2];
				$this->episodeName = $matches[1];

				$replace = $matches[2] . DIRECTORY_SEPARATOR . $matches[1];

				$this->target = str_replace( $this->episodeName, $replace, $this->target );
				$this->command = str_replace( $matches[0], $this->target, $this->command );
			}
			else
			{
				throw new Exception( "Error extracting files from the command: {$this->command}" );
			}

			$this->title = $this->episodeName;
			$this->linkTarget = "/media/aggregateshares/TV Shows/{$this->showName}/";
		}
	}

	/**
	 * Analyzes the command and stores the conversion type (movie / tvshow)
	 * in self::$type
	 */
	protected function _extractType()
	{
		if ( strpos( $this->command, '/complete/Movies/' ) !== false )
		{
			$this->conversionType = 'movie';
		}
		elseif ( strpos( $this->command, '/complete/TV/' ) !== false )
		{
			$this->conversionType = 'tvshow';
		}
		else
			throw new Exception( "Unable to extract the conversion type" );
	}

	/**
	 * Returns the command string formatted according to a few settings:
	 * {@link $appendSymLink} Wether or not to append a symbolic link creation command
	 * {@link $appendDoneText} Wether or not to append a message saying confirmation's complete
	 *
	 * @return string
	 */
	public function __toString()
	{
		$string = $this->command;
		if ( $this->appendSymLink === true )
			$string .= "; ln -s \"{$this->target}\" \"{$this->linkTarget}\"";
		if ( $this->appendDoneText === true )
			$string .= "; echo \"Done converting {$this->title}\"";

		return $string;
	}

	public function __get( $property )
	{
		switch ( $property )
		{
			case 'videoFiles':
				return $this->_extractCommandFiles( 'video' );
				break;
			case 'subtitleFiles':
				return $this->_extractCommandFiles( 'subtitle');
				break;
			default:
				throw new ezcBasePropertyNotFoundException( $property );
		} // switch
	}

	/**
	 * Returns the video files involved in the command
	 * @param string $type subtitle or video
	 * @return string
	 */
	protected function _extractCommandFiles( $type )
	{
		$return = array();

		switch ( $type)
		{
			case 'video':
			{
				$extensions = '(avi|mkv)';
			} break;

			case 'subtitle':
			{
				$extensions = '(srt|ass)';
			} break;

			default:
				throw new UnexpectedValueException( "Invalid argument given to " . __FUNCTION__ );
		}
		if ( preg_match_all( "#/home/download/downloads/complete/(TV/Sorted|Movies)/([^\/]+)/([^\"]+\.{$extensions})#", $this->command, $matches ) )
		{
			foreach( $matches[0] as $match )
			{
				$return[] = basename( $match );
			}
		}

		return $return;
	}


	/**
	 * The final command, after conversion
	 * @var string
	 */
	public $command;

	/**
	 * Conversion type: movie/tvshow
	 */
	public $conversionType;

	/**
	 * The conversion title, either the movie name, or the tv show name + episode
	 * @var string
	 */
	public $title;

	/**
	/**
	 * The conversion target folder
	 * @var string
	 */
	public $target;

	/**
	 * The TV Show name. Only set for $type == tvshow
	 * @var string
	 */
	public $showName;

	/**
	 * The TV Show episode name. Only set for $type == tvshow
	 * @var string
	 */
	public $episodeName;

	/**
	 * The target to be used as the symbolic link
	 * @var string
	 */
	public $linkTarget;

	/**
	 * The command time, as stored in the queue. Optional.
	 * @var int timestamp
	 */
	public $time;

	public $appendSymLink = false;

	public $appendDoneText = false;
}
?>